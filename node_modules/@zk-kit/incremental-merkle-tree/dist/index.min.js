/**
 * @module @zk-kit/incremental-merkle-tree
 * @version 0.4.3
 * @file Incremental Merkle tree implementation in TypeScript.
 * @copyright Omar Desogus 2022
 * @license MIT
 * @see [Github]{@link https://github.com/appliedzkp/zk-kit/tree/main/packages/incremental-merkle-tree}
*/
var zkKitIncrementalMerkleTree=function(e){"use strict";function t(e,t){for(var r=[],o=2;o<arguments.length;o++)r[o-2]=arguments[o];if(void 0===e)throw new TypeError("Parameter '".concat(t,"' is not defined"));if(!r.includes(typeof e))throw new TypeError("Parameter '".concat(t,"' is none of these types: ").concat(r.join(", ")))}function r(e,r,o,n,i,s,h){if(t(e,"index","number"),e<0||e>=i[0].length)throw new Error("The leaf does not exist in this tree");for(var f=r,a=0;a<o;a+=1){var u=e-e%n,p=u+n,c=[];i[a][e]=f;for(var l=u;l<p;l+=1)l<i[a].length?c.push(i[a][l]):c.push(s[a]);f=h(c),e=Math.floor(e/n)}return f}var o=function(){function e(r,o,n,i){if(void 0===i&&(i=2),t(r,"hash","function"),t(o,"depth","number"),t(n,"zeroValue","number","string","bigint"),t(i,"arity","number"),o<1||o>e.maxDepth)throw new Error("The tree depth must be between 1 and 32");this._hash=r,this._depth=o,this._zeroes=[],this._nodes=[],this._arity=i;for(var s=0;s<o;s+=1)this._zeroes.push(n),this._nodes[s]=[],n=r(Array(this._arity).fill(n));this._root=n,Object.freeze(this._zeroes),Object.freeze(this._nodes)}return Object.defineProperty(e.prototype,"root",{get:function(){return this._root},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"depth",{get:function(){return this._depth},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"leaves",{get:function(){return this._nodes[0].slice()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"zeroes",{get:function(){return this._zeroes},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"arity",{get:function(){return this._arity},enumerable:!1,configurable:!0}),e.prototype.indexOf=function(e){return function(e,r){return t(e,"leaf","number","string","bigint"),r[0].indexOf(e)}(e,this._nodes)},e.prototype.insert=function(e){this._root=function(e,r,o,n,i,s){if(t(e,"leaf","number","string","bigint"),n[0].length>=Math.pow(o,r))throw new Error("The tree is full");for(var h=e,f=n[0].length,a=0;a<r;a+=1){var u=f-f%o,p=u+o,c=[];n[a][f]=h;for(var l=u;l<p;l+=1)l<n[a].length?c.push(n[a][l]):c.push(i[a]);h=s(c),f=Math.floor(f/o)}return h}(e,this.depth,this.arity,this._nodes,this.zeroes,this._hash)},e.prototype.delete=function(e){this._root=r(e,this.zeroes[0],this.depth,this.arity,this._nodes,this.zeroes,this._hash)},e.prototype.update=function(e,t){this._root=r(e,t,this.depth,this.arity,this._nodes,this.zeroes,this._hash)},e.prototype.createProof=function(e){return function(e,r,o,n,i,s){if(t(e,"index","number"),e<0||e>=n[0].length)throw new Error("The leaf does not exist in this tree");for(var h=[],f=[],a=e,u=0;u<r;u+=1){var p=e%o,c=e-p,l=c+o;f[u]=p,h[u]=[];for(var b=c;b<l;b+=1)b!==e&&(b<n[u].length?h[u].push(n[u][b]):h[u].push(i[u]));e=Math.floor(e/o)}return{root:s,leaf:n[0][a],pathIndices:f,siblings:h}}(e,this.depth,this.arity,this._nodes,this.zeroes,this.root)},e.prototype.verifyProof=function(e){return function(e,r){t(e,"proof","object"),t(e.root,"proof.root","number","string","bigint"),t(e.leaf,"proof.leaf","number","string","bigint"),t(e.siblings,"proof.siblings","object"),t(e.pathIndices,"proof.pathElements","object");for(var o=e.leaf,n=0;n<e.siblings.length;n+=1){var i=e.siblings[n].slice();i.splice(e.pathIndices[n],0,o),o=r(i)}return e.root===o}(e,this._hash)},e.maxDepth=32,e}();return e.IncrementalMerkleTree=o,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
