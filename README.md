# Designated Verifier ZKP

The designated verifier circuit is a pluggable component that can be included to **add a designated verifier** inside any zkSNARK. This means that the prover can choose the designated verifier. The prover will be able to convince only the designated verifier of the veracity of that proof. Everyone else accessing wouldn't be able to tell whether the proof was actually generated by the prover or forged by the designated verifer.

Inspired by : 

- [Jordi Baylina - ZKP and SSI - Iden3](https://www.youtube.com/watch?v=Rd6SMShk7-c&t=998s)
- [Markus Jakobsson - Designated Verifier Proofs and Their Applications paper](http://markus-jakobsson.com/papers/jakobsson-eurocrypt96.pdf)

## Setup 

- Install package dependencies `npm i`
- Clone submodule from root directory `git submodule update --init`
- Install sub module dependencies `cd circom-ecdsa / npm i`


## Key concept of Designated Verifier ZKproof

The essence of the Designated Verifier ZKproof is based on a simple yet very powerful concept. Let's consider an example. In a non-designated Verifier ZKproof context a prover is proving that she knows a preimage of a public hash without revealing the preimage. In this scenario the prover generates a proof and passes it to a Verifier. The verifier is able to check that prover know the preimage of a public hash. The verifier is now also able to share this proof with third parties and *anyone will be persuaded* by the fact "prover knows the preimage of the public hash".

In a Designated Verifier ZKproof scenario the prover is proving that she knows a preimage of a public hash (without revealing the preimage) *OR* that she knows the private key of the designated verifier. Again, the prover generates the proof and passes it to the verifier. We suppose that the key of the verifier hasn't been compromised by the prover and that the verifier is aware of that. Starting from the proof, the verifier is able to check that prover know the preimage of a public hash. The verifier is now not able to share this proof with third parties as other parties wouldn't know whether: 

- The proof shared by the designated verifier verifies because the prover knows the preimage of the public hash
- The proof shared by the designated verifier verifies because the verifier know his own private key (which is true by definition)

In this second scenario *only the Designated Verifier will be persuaded* by the fact "prover knows the preimage of the public hash".

## Circuit Design 

Let's get a bit more technical.

- [ ] Add Miro illustration of circuit design

## Testing

Test `bash scripts/build_witness.sh`

To test `mocha test/dvs.js`. Likely you will run into some errors. That's because your computer is not able to handle the huge number of constraints and gates included in this circuit. 

Test #1 => Prover wants to communicate something to the designated verifier 
"I have a secret x". Sign the message and use it inside the zkSNARK. 

Test #2 => Designated verifier wants to share with other people the message sent him by the Prover 
Test #3 => Designated verifier wants to share with other people forging a false message sent him by the Prover 

## Plug into your SNARK

- [ ] Add instructions about how to modify your current circuit to accomodate the SVZkp

## Done 

Testing Signature with valid and false signature


## To do 

WIP TO DO BOARDS => https://github.com/users/enricobottazzi/projects/6

- [ ] Add address as input somehow
- [ ] Test is not working, check again 
- [ ] Modify circuit to accomodate pubkey check

## Questions 

- [ ] How can I access someone's publickey? => By signature actually! 
- [ ] What is the sense of ff javascript?

## Run a server

